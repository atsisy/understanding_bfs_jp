#+TITLE: Boot File SystemのLinux実装を読む file.c編

Linux ke





rnel 4.14.5のfs/bfs/file.cを対象にソースコードを読んでいきます。

* ブロック操作
** bfs_move_block関数
*** 概要
    あるブロックのデータを他のブロックにコピーする。
    関数名はmoveだが、アセンブリのmovのような意味。
*** 引数
**** 第一引数
     unsinged long from
     コピー元のブロックの論理番号
**** 第二引数
      unsigned long to
      コピー先のブロックの論理番号
**** 第三引数
    struct super_block *sb
    このファイルシステムのスーパブロックを表すsuper_block構造体へのポインタ
*** 返り値
    終了ステータスを返す。成功すれば0が、失敗すればそのエラーコードが返る。
*** 1行目
    バッファキャッシュを指し、参照カウントを保持する構造体であるbuffer_head構造体へのポインタ型変数の
    bh、newを宣言しています。
*** 2行目
    sb_bread関数でバッファキャッシュを作り出しています。sb_bread関数に渡す引数は、
    bfs_move_block関数が受け取った引数であるsuper_block構造体のsb、ブロックの論理番号が
    格納されているfromを渡している。これにより、fromが指す1ブロック分のデータをメモリにキャッシュできます。
*** 3~4行目
    sb_breadが失敗した場合、NULLが帰ってきます。NULLが帰ってきていた場合、EIOエラーコードを返して終了します。
*** 5行目
    sb_getblk関数が使われています。この関数の動作がいまいちわからないので、ソースコードを見てみることにします。
#+BEGIN_SRC c
/////
// include/linux/buffer_head.h sb_getblk関数
/////
static inline struct buffer_head *
sb_getblk(struct super_block *sb, sector_t block)
{
	return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, __GFP_MOVABLE);
}

/////
// fs/buffer.c __getblk_gfp関数
// sb_getblk関数から呼び出されている
/////
/*
 * __getblk_gfp() will locate (and, if necessary, create) the buffer_head
 * which corresponds to the passed block_device, block and size. The
 * returned buffer has its reference count incremented.
 *
 * __getblk_gfp() will lock up the machine if grow_dev_page's
 * try_to_free_buffers() attempt is failing.  FIXME, perhaps?
 */
struct buffer_head *
__getblk_gfp(struct block_device *bdev, sector_t block,
	     unsigned size, gfp_t gfp)
{
	struct buffer_head *bh = __find_get_block(bdev, block, size);

	might_sleep();
	if (bh == NULL)
		bh = __getblk_slow(bdev, block, size, gfp);
	return bh;
}
#+END_SRC
    __getblk_gfp関数の上部のコメントを読むと、どうやらbuffer_head構造体を確保する関数のようです。
    また、sb_breadが呼び出している__bread_gfpのソースを見てみると、その中で__getblk_gfpを呼び出しています。
    なので、だいたい同じ処理をしますが、違いは、キャッシュされているかを調べているかがsb_getblkで、
    調べないのがsb_breadかと思われます。
*** 6行目
    buffer_head構造体のb_sizeフィールドにはブロックのサイズが格納されているため、
    newが指すキャッシュにbhのキャッシュを上書きすることになります。
*** 7行目
    newが指すキャッシュに変更があり、ディスクの情報と矛盾が生じていること通知します。
*** 8行目
    bforget関数は初出ですので、ソースを詳しく見ていきます。
    基本的な動作はbrelseに似ています。
#+BEGIN_SRC c
/////
// include/linux/buffer_head.h bforgot関数
/////
static inline void bforget(struct buffer_head *bh)
{
	if (bh)
		__bforget(bh);
}

/////
// fs/buffer.c __bforget関数
/////
/*
 * bforget() is like brelse(), except it discards any
 * potentially dirty data.
 */
void __bforget(struct buffer_head *bh)
{
	clear_buffer_dirty(bh);
	if (bh->b_assoc_map) {
		struct address_space *buffer_mapping = bh->b_page->mapping;

		spin_lock(&buffer_mapping->private_lock);
		list_del_init(&bh->b_assoc_buffers);
		bh->b_assoc_map = NULL;
		spin_unlock(&buffer_mapping->private_lock);
	}
	__brelse(bh);
}
#+END_SRC
    コメントを見る限り、bforgot関数は、brelseとは異なり、その場ですぐにそのデータを破棄するようです。
    それは、誰かがそのキャッシュを参照していたとしても削除します。ここがbrelse関数とは異なる点です。
*** 9行目
    brelse関数でnewを解放します。これはbrelseでの解放なので、誰かがこのキャッシュを参照
    していた場合、すぐには解放されません。
*** 10行目
    エラーは起きなかったので、0を返却します。
    
** bfs_move_blocks関数
*** 概要
    複数のブロックのデータを一度にコピーする関数
*** 引数
**** 第一引数
     struct super_block *sb
     このファイルシステムのスーパブロックを表すsuper_block構造体
**** 第二引数
     unsigned long start
     コピーを開始するブロックの論理番号
**** 第三引数
     unsigned long end
     コピーを終了するブロックの論理番号
**** 第四引数
     unsigned long where
     コピー先の先頭ブロックの論理番号
*** 返り値
    成功した場合は0、失敗した場合は-EIOが返る。
*** 1行目
    カウンタ変数としてunsigned int型で変数iを宣言しています。
*** 2行目
    デバッグ用出力として、複製の開始ブロックと終了地点のブロックの論理番号、さらに、コピー先の
    先頭のブロックの論理番号を出力しています。
*** 3~8行目
**** 3行目
     forループです。iはstartからendまでの範囲を1ずつ増えていきます。
**** 4行目
     bfs_move_block関数を呼び出しています。これにより、iからwhere+1のブロックにデータがコピーされます。
     この関数は、成功すると0を返します。失敗すると、-EIOを返すため、失敗した場合、次のコードに進みます。
     成功すれば、そのままループが継続されます。
**** 5~7行目
     このコードに到達するのは、bfs_move_block関数が失敗したときです。
     処理の内容としては、失敗したことを伝えるメッセージを出力し、EIOエラーを返して終了します。
     エラーメッセージには、コピーに失敗したブロックの論理番号を出力します。
**** 8行目
     何事も無く終了したため、0を返し、成功を伝えます。
** bfs_get_block関数
*** 概要
    bfs_get_block関数は、bfs_readpage関数や、bfs_writepage関数でカーネルにその関数ポインタを渡されています。
    この関数が行うべき処理は、inodeが指すファイルの指定ブロック番号(引数 sector_t block)がディスク上のどのブロックにマップされているかを
    論理番号で返すというものです。
    ※この関数についての説明は解説を行っている記事によって異なる情報がいくつもありましたが、今回はとりあえずこれで概要とします※
*** 引数
    | 第一引数 | struct inode *inode           | 指定するファイルのinode                                                        |
    | 第二引数 | sector_t block                | カーネル向け論理番号を知りたい、ファイルの先頭ブロックからのブロックオフセット |
    | 第三引数 | struct buffer_head *bh_result | 結果を格納するためのバッファを指すbuffer_head構造体へのポインタ                |
    | 第四引数 | int create                    | ファイルの拡張を行うかどうかのフラグ                                                                                         |
*** 返り値
    終了ステータスを返します。
    | ステータス | 返り値  |
    | 正常終了   | 0       |
    | 領域不足   | -ENOSPC |
*** 1~5行目
    各種変数宣言を行っています。
    一応、下の3つの変数について軽く説明を行いたいと思います。
**** struct super_block *sb = inode->i_sb;
     inode構造体のi_sbフィールドには、このファイルシステムのスーパブロックを表すsuper_block構造体へのポインタ
     が格納されています。（inode.c編 bfs_write_inode関数 1~4行目参照）
     これをsuper_block構造体へのポインタであるsbに代入しています。
**** struct bfs_sb_info *info = BFS_SB(sb);
     BFS_SBインライン関数は、super_block構造体のs_fs_infoフィールドを取り出し、返します。
     s_fs_infoにはファイルシステムのプライベートな情報を格納していて（bfs_sb_info）これを
     infoに代入しています。
**** struct bfs_inode_info *bi = BFS_I(inode);
     BFS_Iインライン関数は引数に受け取ったinode構造体が所属しているbfs_inode_info構造体へのポインタを返します。
     つまりそういうことです。
*** 6行目
    変数physにbi->i_sblock（ファイルの開始ブロックの論理番号）と引数で受け取ったsector_t型のblockの和
    を代入しています。このblockはカーネルが管理するこのファイルシステムの論理ブロック番号になります。
    これによって、ファイルが位置しているであろうブロックがディスク上のどこの論理番号を持つかを一応計算
    することができます。
*** 7行目
    引数で渡されるカーネルからの指定である、createフラグを確認しています。
    createフラグが立っている場合、指定されたファイルが存在していないとき、
    新規ファイルを作成し、返すべきブロックの論理番号を計算しようとします。
    ここの分岐では、createフラグが立っていない場合にtrueになり、ブロック内の処理を実行していきます。
    createフラグが立っている場合は、後ろにずらずらと書いてある処理を実行していくことになります。
*** 8行目
    bi->i_eblockはinodeが指すファイルの終端ブロックの論理番号が格納されています。
    これが、先程計算したphysよりも小さい時、目的の値の計算を行っていき、falseだった場合は、
    失敗として、何も行わず0を返します。
    なぜ、phys <= bi->i_eblockがfalseだと失敗なのかというと、要求されたファイルのブロック番号は、ファイルの終端のブロック番号
    よりも小さい、つまり、要求されたブロックはそのファイルに使用されていないということであり（オーバランしている）、処理は遂行できないので、失敗となります。
    ※ここで言う目的の値とは、引数で受け取ったinodeが指すファイルの先頭ブロックから引数で受け取ったブロックの論理番号分先の
    論理番号です。※
*** 9行目
    デバッグ用出力として、createフラグ、block、physを表示しています。
*** 10行目
    ここではmap_bh関数を使用して引数で受け取っているbuffer_head構造体のポインタが指すオブジェクトに
    計算結果を適用しています。これだけで終わると味気ないので、map_bh関数のソースを簡単に読んでことにします。(コメントだけ)
#+BEGIN_SRC c
/////
// include/linux/buffer_head.h map_bh関数
/////
static inline void
map_bh(struct buffer_head *bh, struct super_block *sb, sector_t block)
{
        /** 筆者コメント **/
	// 恐らく、このバッファは使用済みですというフラグを立てている(?)
	//
	set_buffer_mapped(bh);

	/** 筆者コメント **/
	// ブロックデバイス情報をコピー
	//
	bh->b_bdev = sb->s_bdev;

	/** 筆者コメント **/
	// 計算したブロックの論理番号を代入
	//
	bh->b_blocknr = block;

	/** 筆者コメント  **/
	// このbuffer_headが指すマップされた領域のサイズを設定。
	// sb->s_blocksizeは1ブロック当たりのサイズ
	//
	bh->b_size = sb->s_blocksize;
}
#+END_SRC
*** 12行目
    0を返して終了
*** 15~18行目
    19行目に出現するif分岐の説明を行っています。
    適当に訳したものをいかに示しておきます。

#+BEGIN_SRC

    ファイルが空でなく、リクエストされたブロックが、このファイルが確保されているブロック領域範囲内であれば、
    それはtrueとする。

#+END_SRC
    
    という具合でしょうか。
*** 19行目
    19行目です。以下のようなコードになっています。
#+BEGIN_SRC c
    if (bi->i_sblock && (phys <= bi->i_eblock)){ //~~// }
#+END_SRC
    上の15~18行目のコメントを見ると、このif文の意味が理解できると思います。
    bi->i_sblockはファイルが書き込まれているブロック領域の先頭のブロックの論理番号が格納されています。
    つまり、bi->i_sblockが0ではない、有効な値を持っていれば、一つ目の条件はtrueになります。
    ２つ目の条件、phys <= bi->i_eblockは、8行目と同じ条件です。
    計算した値phys（指定されたファイルの、指定されたブロックオフセット分のブロックの論理番号）がファイルの末端ブロック
    以下であることで、trueとなります。（オーバランしていない）
*** 20~23行目
    9~12行目と同様の処理を行っています。
*** 25行目
    26行目に出現するif分岐の説明を行っています。
    適当に訳したものを以下に示しておきます。

#+BEGIN_SRC

    ファイルは拡張されます。なので、ファイルを拡張する分だけの十分な領域があるか見てみましょう。

#+END_SRC

    簡単ですね。
*** 26行目
    条件式: if (phys >= info->si_blocks)の解説を行いたいと思います。
    info->si_blocksには、このファイルシステムが持つブロックの総数が格納されています。

    （この場合は、createフラグが立っているため、ファイルが拡張されることを頭に入れておいてください）
    つまり、要求されるブロック番号が、ブロックの総数よりも大きいかどうかを確認しています。
    BFSでは、基本的にファイルは連続したブロックで管理されます（連続アロケーション）。なので、この条件式
    により、拡張に十分な領域があるかどうかを確認できるわけです。
**** 余談
     連続アロケーションはファイルシステムにおけるファイルのマップ方法の一つです。
     この他にも、リンクリストアロケーションなどの手法があります。
*** 27行目
    26行目の条件式がtrueになるということは、拡張に十分な領域が存在していないということです。
    したがって、処理を継続することは困難なので、ENOSPCエラーを返して終了しています。
*** 30行目
    mutex_lockでinfo->bfs_lockのロックを掛けています。
    この先、ファイルの拡張やら、移動が行われることが予想されるため、ここでロックを掛けているのでしょう。
    上部のコメントを読んでみると、

#+BEGIN_SRC
    残りは自分自身から保護されています。
#+END_SRC

    コメントはよくわからないですが、コードを見れば、やりたいことはわかるはずです。
*** 32~36行目
    ながながと37行目のif文とそのブロックについて記述してありますが、訳してしまえば、簡単です。
    
#+BEGIN_SRC
    もし、このファイルの末端ブロックが、このファイルシステムで使用済みの最後ブロックだった場合、
    特にファイルの移動等をやること無く、拡張できますね。
#+END_SRC

    てな感じで書いてあります。
*** 37行目
    if (bi->i_eblock == info->si_lf_eblk)
    この条件式は、上部のコメントどおりの処理になっています。
    info->si_lf_eblkはこのファイルシステムに存在するファイルのEOFが書き込まれているブロックの論理番号が格納されています。
    (inode.c編に記述していたと思います)
    そして、bi->i_eblockは、このファイルの末端ブロックの論理番号を示すため、この条件式が表すことは、以下のようになります。
    

    このファイルの末端ブロックの論理番号とこのファイルシステムに存在するファイルのEOFが書き込まれているブロックの論理番号が等しい


    まさに上部のコメントどおりといったところでしょうか。
*** 38~40行目
    9~12行目,20~23行目と同様の処理を行っています。
*** 41行目
    info->si_freeb -= phys - bi->i_eblock
    info->si_freebはこのファイルシステムに存在している空きブロックの数になっています。
    phys - bi->i_eblockの計算結果は、ファイルをあと何ブロック拡張する必要があるかを表します。
    つまり、ファイルを拡張する分だけ、空きブロックの数を減らしています。
*** 42行目
    info->si_lf_eblk = bi->i_eblock = phys
    このブロックに入ってくる条件として、37行目の条件式を満たす必要があります。
    条件を満たす要件は37行目の解説で行っているので、それを理解した上での説明をします。
    
    physの値までブロックを拡張しなければいけないわけですから、必然的に、
    現在のファイルの末端ブロックの値は、physになり、
    info->si_lf_eblkもphysになるわけです。
*** 43行目
    メモリ上のinodeの内容を変更し、ディスクの内容と矛盾が生じているため、mark_inode_dirty関数を使い、
    dirty状態にしています。いい感じの頃合いに、ディスク上のデータは変更されます。
*** 44,45行目
    終了ステータスを格納しておくerr変数に、通常終了を知らせる0を代入し、
    outラベルにジャンプしています。
*** 48行目
    これ以降の処理について簡単にコメントを残しています。
    いい感じに翻訳してみたいと思います。

#+BEGIN_SRC
    OK. このファイル全体を、拡張を行うために、次の空きブロック領域に移す必要があります。
#+END_SRC

    この翻訳だと、誤解を生みかねないので、図を作りました。そちらも参考にしてください。
    
[[./image/get_block1.png]］
[[./image/get_block2.png]］

*** 49行目
    phys = info->si_lf_eblk + 1
    この処理は上記のコメントを早とちりしてしまうと、意味がわからなくなってしまうかもしれません。
    ここで行っていることは、ただ単に、physに次の空きブロック領域の先頭の論理番号を代入しているだけです。
*** 50行目
#+BEGIN_SRC c
    if (phys + block >= info->si_blocks)
#+END_SRC
    ここで、条件分岐が発生します。
    まず、phys + blockは、ファイル移動後の、求めていた論理番号となります。なぜなら、上の行でphysには
    次の空き領域の先頭のブロックの論理番号が入っていて、それにblockを足しているからです。
    
    そして、その値が、info->si_blocksよりも大きいかどうか判定しています。info->si_blocksにはこのファイルシステム
    が持つ総ブロック数が格納されています。したがって、左辺のほうが大きいとなると、このファイルシステムに収まりきらず
    オーバーフローしてしまいます。なので、次の2行に示されるエラー処理に移るわけです。
*** 51,52行目
    終了ステータスを格納しておくerr変数に、-ENOSPCを代入しています。この理由は、50行目の解説で行っています。
    その後、outラベルにジャンプして終了です。
*** 55行目
#+BEGIN_SRC c
    if (bi->i_sblock)
#+END_SRC
    この条件式は単純ですね。bi->i_sblockにはファイルの開始ブロックの論理番号が格納されています。
    この値が0になるということは、普通ありえないので、移動の作業は行いません。
    それ以外の場合、移動作業に写っていきます。
*** 56,57行目
    bfs_move_blocks関数を呼び出し、その返り値をerr変数に代入しています。
    bfs_move_blocks関数については、上で解説を行っているので、それを参照してください。
    ひとまず、これで移動作業が行われ、その終了状況がerr変数に代入されました。
*** 58行目
    bfs_move_blocks関数の返り値はerrに格納されています。正常終了の場合、errには0が格納され、
    エラーだった場合は、0以外の値が入っています。したがって、この条件式

#+BEGIN_SRC c
    if (err)
#+END_SRC

    これは、エラーの場合、trueになるわけですね。
*** 59~61行目
    ファイルの移動がエラーで終了した場合、この処理を実行することになります。
    実行する処理としては、デバッグ用出力として、inode番号を出力しています。
    その後、outラベルにジャンプしています。
*** 64行目
    55行目で行った条件分岐で、bi->i_sblockの値が、0のだった場合、ここの処理が実行されます。
    見たまんまで、err変数に0を代入しているだけです。
*** 65,66行目
    デバッグ用の出力を行っています。
*** 67行目
    ファイルの移動を行ったため、もちろん、ファイルの開始ブロックの論理番号情報は変更されなければなりません。
    なので、bi->i_sblockにphysを格納しています。
    （physには、移動先の先頭ブロックの論理番号が格納されています。49行目参照）
*** 68行目
    physにblockを足しています。これは、この関数で求めるべき値となります。
    やっとここで、本題の処理を行うことができるわけです。
*** 69行目
#+BEGIN_SRC c
    info->si_lf_eblk = bi->i_eblock = phys
#+END_SRC
    ファイルは空き領域の先頭へ移動され、さらに拡張されているため、info->si_lf_eblk(使用されている最後のブロック)と
    bi->i_eblock（このファイルの末端ブロック）にはphysが入るべきです。なので、この処理を行っています。
*** 71~74行目
    ここの部分のコメントは次の計算の説明を行っています。
    コメントの訳を以下に示します。
#+BEGIN_SRC

ここにいる間は、誰もinodeに書き込めないと仮定します。
したがって、inode->i_blocksを更新してください。

#+END_SRC
    
    プログラム中では、inode->i_blocksに変更を加えているコードはどこにもありませんが、どこでupdateしているのでしょうか
*** 75行目
    ここでは次のような計算を行っています。
#+BEGIN_SRC c
    bi->i_eblock - bi->i_sblock + 1 - inode->i_blocks;
    /*
    移動先のファイルの末端ブロックの論理番号 - 移動先のファイルの開始ブロックの論理番号
                                  + 1 - 元々ファイルが使用していたブロックの総数
    */
#+END_SRC
    この計算から読み取れることとしては、以下のように理解していくことができます。
**** 1.bi->i_eblock - bi->i_sblock + 1
     移動後のファイルが使用するブロックの総数
**** 2.1の計算結果 - inode->i_blocks
     新しく使用することになったブロックの総数 - 元々使用していたブロック総数ですから、
     空きブロックの数がこの計算で求めることができるわけですね。
*** 76行目
    inodeをdirty状態にし、いい頃合いでディスクにその内容が反映されるようにしています。
*** 77行目
    map_bh関数で、求めたphysらをバッファに適用ししています。
    map_bh関数については、10行目の解説の部分で触れているので、詳しいどうさはそこを参照してください。
*** 78行目
    outラベルです。
    これ以降はミューテックスロックを解除して終了となります。
*** 79行目
    inodeの変更に関わる処理は終了したので、このファイルシステム用のmutexを解除しています。
*** 80行目
    終了ステータスを返して終了です。
* ページ処理
** bfs_readpage関数
*** 概要
    引数で渡されるpage構造体が指すページに対応するブロックからデータを読み取り、
    そのデータをページキャッシュに格納する処理をベースとして、BFS独自に実装を行う。
*** 引数
**** 第一引数
     struct file *file
     今回は使用しません。
**** 第二引数
     struct page *page
     データを格納するページを表すpage構造体へのポインタ
*** 返り値
    基本的に0を返します。
*** 1行目
    block_read_full_page関数を呼び出しています。その結果を返し、終了です。
    この関数に渡している引数は、ページキャッシュを指すpage構造体へのポインタと、
    BFSのブロックを読み込むための関数であるbfs_get_blockの関数ポインタを渡しています。
    ここで軽くblock_read_full_page関数について説明を行っていきます。
**** block_read_full_page関数
***** 概要
      引数で渡されるpage構造体が指すページに対応するブロックからデータを読み取り、
      そのデータをページキャッシュに格納します。
***** ソースコード
#+BEGIN_SRC c
/////
// fs/buffer.c block_read_full_page関数
/////
/*
 * Generic "read page" function for block devices that have the normal
 * get_block functionality. This is most of the block device filesystems.
 * Reads the page asynchronously --- the unlock_buffer() and
 * set/clear_buffer_uptodate() functions propagate buffer state into the
 * page struct once IO has completed.
 */
int block_read_full_page(struct page *page, get_block_t *get_block)
{
	struct inode *inode = page->mapping->host;
	sector_t iblock, lblock;
	struct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];
	unsigned int blocksize, bbits;
	int nr, i;
	int fully_mapped = 1;

	head = create_page_buffers(page, inode, 0);
	blocksize = head->b_size;
	bbits = block_size_bits(blocksize);

	iblock = (sector_t)page->index << (PAGE_SHIFT - bbits);
	lblock = (i_size_read(inode)+blocksize-1) >> bbits;
	bh = head;
	nr = 0;
	i = 0;

	do {
		if (buffer_uptodate(bh))
			continue;

		if (!buffer_mapped(bh)) {
			int err = 0;

			fully_mapped = 0;
			if (iblock < lblock) {
				WARN_ON(bh->b_size != blocksize);
				err = get_block(inode, iblock, bh, 0);
				if (err)
					SetPageError(page);
			}
			if (!buffer_mapped(bh)) {
				zero_user(page, i * blocksize, blocksize);
				if (!err)
					set_buffer_uptodate(bh);
				continue;
			}
			/*
			 * get_block() might have updated the buffer
			 * synchronously
			 */
			if (buffer_uptodate(bh))
				continue;
		}
		arr[nr++] = bh;
	} while (i++, iblock++, (bh = bh->b_this_page) != head);

	if (fully_mapped)
		SetPageMappedToDisk(page);

	if (!nr) {
		/*
		 * All buffers are uptodate - we can set the page uptodate
		 * as well. But not if get_block() returned an error.
		 */
		if (!PageError(page))
			SetPageUptodate(page);
		unlock_page(page);
		return 0;
	}

	/* Stage two: lock the buffers */
	for (i = 0; i < nr; i++) {
		bh = arr[i];
		lock_buffer(bh);
		mark_buffer_async_read(bh);
	}

	/*
	 * Stage 3: start the IO.  Check for uptodateness
	 * inside the buffer lock in case another process reading
	 * the underlying blockdev brought it uptodate (the sct fix).
	 */
	for (i = 0; i < nr; i++) {
		bh = arr[i];
		if (buffer_uptodate(bh))
			end_buffer_async_read(bh, 1);
		else
			submit_bh(REQ_OP_READ, 0, bh);
	}
	return 0;
}
#+END_SRC
***** 処理の流れ
      1.buffer_head構造体の初期化（データの読み出し）
      2.初期化のエラーチェック
      3.バッファをロックし、同期を行う
      4.既にバッファが最新状態なら、そのバッファのREAD I/Oが終了したことをカーネルに通知し、
        そうでなければ、submit_bh関数を使って、カーネルに1ブロック分のデータを要求します。
	このとき、buffer_head構造体にブロックの論理番号などの情報が入っているので、
	submit_bhには読み込みを要求するREQ_OP_READとオプション（0）、bhだけを渡しています。
** bfs_writepage関数
*** 概要
    引数で渡されるpage構造体が指すページに対応するキャッシュを記憶装置と矛盾が無いように書き込む要請
    をカーネルに行います。これをBFSに対応した形で定義を行います。
*** 引数
**** 第一引数
     struct page *page
     Dirtyな状態のページキャッシュを指すpage構造体へのポインタ。
**** 第二引数
     struct writeback_control *wbc
     WriteBack処理を管理するためのwriteback_control構造体へのポインタ。
     WriteBack処理等を自前で実装するときに必要になるため、カーネルから渡される。
*** 返り値
*** 1行目
    block_write_full_page関数を呼び出しています。その結果を返し、終了です。block_read_full_pageと似ています。
    この関数に渡している引数は、ページキャッシュを指すpage構造体へのポインタと、
    BFSのブロックを読み込むための関数であるbfs_get_blockの関数ポインタを渡しています。
**** block_write_full_page関数
     block_read_full_page関数と同様で、WriteBack処理を行うための関数です。この関数が主に扱う処理は、
     WriteBack処理の書き込み操作の部分です。渡したDirtyなページの情報の同期をカーネルに要請します。
