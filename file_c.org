#+TITLE: Boot File SystemのLinux実装を読む file.c編

Linux kernel 4.14.5のfs/bfs/file.cを対象にソースコードを読んでいきます。

* ブロック操作
** bfs_move_block関数
*** 概要
    あるブロックのデータを他のブロックにコピーする。
    関数名はmoveだが、アセンブリのmovのような意味。
*** 引数
**** 第一引数
     unsinged long from
     コピー元のブロックの論理番号
**** 第二引数
      unsigned long to
      コピー先のブロックの論理番号
**** 第三引数
    struct super_block *sb
    このファイルシステムのスーパブロックを表すsuper_block構造体へのポインタ
*** 返り値
    終了ステータスを返す。成功すれば0が、失敗すればそのエラーコードが返る。
*** 1行目
    バッファキャッシュを指し、参照カウントを保持する構造体であるbuffer_head構造体へのポインタ型変数の
    bh、newを宣言しています。
*** 2行目
    sb_bread関数でバッファキャッシュを作り出しています。sb_bread関数に渡す引数は、
    bfs_move_block関数が受け取った引数であるsuper_block構造体のsb、ブロックの論理番号が
    格納されているfromを渡している。これにより、fromが指す1ブロック分のデータをメモリにキャッシュできます。
*** 3~4行目
    sb_breadが失敗した場合、NULLが帰ってきます。NULLが帰ってきていた場合、EIOエラーコードを返して終了します。
*** 5行目
    sb_getblk関数が使われています。この関数の動作がいまいちわからないので、ソースコードを見てみることにします。
#+BEGIN_SRC c
/////
// include/linux/buffer_head.h sb_getblk関数
/////
static inline struct buffer_head *
sb_getblk(struct super_block *sb, sector_t block)
{
	return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, __GFP_MOVABLE);
}

/////
// fs/buffer.c __getblk_gfp関数
// sb_getblk関数から呼び出されている
/////
/*
 * __getblk_gfp() will locate (and, if necessary, create) the buffer_head
 * which corresponds to the passed block_device, block and size. The
 * returned buffer has its reference count incremented.
 *
 * __getblk_gfp() will lock up the machine if grow_dev_page's
 * try_to_free_buffers() attempt is failing.  FIXME, perhaps?
 */
struct buffer_head *
__getblk_gfp(struct block_device *bdev, sector_t block,
	     unsigned size, gfp_t gfp)
{
	struct buffer_head *bh = __find_get_block(bdev, block, size);

	might_sleep();
	if (bh == NULL)
		bh = __getblk_slow(bdev, block, size, gfp);
	return bh;
}
#+END_SRC
    __getblk_gfp関数の上部のコメントを読むと、どうやらbuffer_head構造体を確保する関数のようです。
    また、sb_breadが呼び出している__bread_gfpのソースを見てみると、その中で__getblk_gfpを呼び出しています。
    なので、だいたい同じ処理をしますが、違いは、キャッシュされているかを調べているかがsb_getblkで、
    調べないのがsb_breadかと思われます。
*** 6行目
    buffer_head構造体のb_sizeフィールドにはブロックのサイズが格納されているため、
    newが指すキャッシュにbhのキャッシュを上書きすることになります。
*** 7行目
    newが指すキャッシュに変更があり、ディスクの情報と矛盾が生じていること通知します。
*** 8行目
    bforget関数は初出ですので、ソースを詳しく見ていきます。
    基本的な動作はbrelseに似ています。
#+BEGIN_SRC c
/////
// include/linux/buffer_head.h bforgot関数
/////
static inline void bforget(struct buffer_head *bh)
{
	if (bh)
		__bforget(bh);
}

/////
// fs/buffer.c __bforget関数
/////
/*
 * bforget() is like brelse(), except it discards any
 * potentially dirty data.
 */
void __bforget(struct buffer_head *bh)
{
	clear_buffer_dirty(bh);
	if (bh->b_assoc_map) {
		struct address_space *buffer_mapping = bh->b_page->mapping;

		spin_lock(&buffer_mapping->private_lock);
		list_del_init(&bh->b_assoc_buffers);
		bh->b_assoc_map = NULL;
		spin_unlock(&buffer_mapping->private_lock);
	}
	__brelse(bh);
}
#+END_SRC
    コメントを見る限り、bforgot関数は、brelseとは異なり、その場ですぐにそのデータを破棄するようです。
    それは、誰かがそのキャッシュを参照していたとしても削除します。ここがbrelse関数とは異なる点です。
*** 9行目
    brelse関数でnewを解放します。これはbrelseでの解放なので、誰かがこのキャッシュを参照
    していた場合、すぐには解放されません。
*** 10行目
    エラーは起きなかったので、0を返却します。
    
** bfs_move_blocks関数
*** 概要
    複数のブロックのデータを一度にコピーする関数
*** 引数
**** 第一引数
     struct super_block *sb
     このファイルシステムのスーパブロックを表すsuper_block構造体
**** 第二引数
     unsigned long start
     コピーを開始するブロックの論理番号
**** 第三引数
     unsigned long end
     コピーを終了するブロックの論理番号
**** 第四引数
     unsigned long where
     コピー先の先頭ブロックの論理番号
*** 返り値
    成功した場合は0、失敗した場合は-EIOが返る。
*** 1行目
    カウンタ変数としてunsigned int型で変数iを宣言しています。
*** 2行目
    デバッグ用出力として、複製の開始ブロックと終了地点のブロックの論理番号、さらに、コピー先の
    先頭のブロックの論理番号を出力しています。
*** 3~8行目
**** 3行目
     forループです。iはstartからendまでの範囲を1ずつ増えていきます。
**** 4行目
     bfs_move_block関数を呼び出しています。これにより、iからwhere+1のブロックにデータがコピーされます。
     この関数は、成功すると0を返します。失敗すると、-EIOを返すため、失敗した場合、次のコードに進みます。
     成功すれば、そのままループが継続されます。
**** 5~7行目
     このコードに到達するのは、bfs_move_block関数が失敗したときです。
     処理の内容としては、失敗したことを伝えるメッセージを出力し、EIOエラーを返して終了します。
     エラーメッセージには、コピーに失敗したブロックの論理番号を出力します。
**** 8行目
     何事も無く終了したため、0を返し、成功を伝えます。
* ページ処理
** bfs_readpage関数
*** 概要
    引数で渡されるpage構造体が指すページに対応するブロックからデータを読み取り、
    そのデータをページキャッシュに格納する処理をベースとして、BFS独自に実装を行う。
*** 引数
**** 第一引数
     struct file *file
     今回は使用しません。
**** 第二引数
     struct page *page
     データを格納するページを表すpage構造体へのポインタ
*** 返り値
    基本的に0を返します。
*** 1行目
    block_read_full_page関数を呼び出しています。その結果を返し、終了です。
    この関数に渡している引数は、ページキャッシュを指すpage構造体へのポインタと、
    BFSのブロックを読み込むための関数であるbfs_get_blockの関数ポインタを渡しています。
    ここで軽くblock_read_full_page関数について説明を行っていきます。
**** block_read_full_page関数
***** 概要
      引数で渡されるpage構造体が指すページに対応するブロックからデータを読み取り、
      そのデータをページキャッシュに格納します。
***** ソースコード
#+BEGIN_SRC c
/////
// fs/buffer.c block_read_full_page関数
/////
/*
 * Generic "read page" function for block devices that have the normal
 * get_block functionality. This is most of the block device filesystems.
 * Reads the page asynchronously --- the unlock_buffer() and
 * set/clear_buffer_uptodate() functions propagate buffer state into the
 * page struct once IO has completed.
 */
int block_read_full_page(struct page *page, get_block_t *get_block)
{
	struct inode *inode = page->mapping->host;
	sector_t iblock, lblock;
	struct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];
	unsigned int blocksize, bbits;
	int nr, i;
	int fully_mapped = 1;

	head = create_page_buffers(page, inode, 0);
	blocksize = head->b_size;
	bbits = block_size_bits(blocksize);

	iblock = (sector_t)page->index << (PAGE_SHIFT - bbits);
	lblock = (i_size_read(inode)+blocksize-1) >> bbits;
	bh = head;
	nr = 0;
	i = 0;

	do {
		if (buffer_uptodate(bh))
			continue;

		if (!buffer_mapped(bh)) {
			int err = 0;

			fully_mapped = 0;
			if (iblock < lblock) {
				WARN_ON(bh->b_size != blocksize);
				err = get_block(inode, iblock, bh, 0);
				if (err)
					SetPageError(page);
			}
			if (!buffer_mapped(bh)) {
				zero_user(page, i * blocksize, blocksize);
				if (!err)
					set_buffer_uptodate(bh);
				continue;
			}
			/*
			 * get_block() might have updated the buffer
			 * synchronously
			 */
			if (buffer_uptodate(bh))
				continue;
		}
		arr[nr++] = bh;
	} while (i++, iblock++, (bh = bh->b_this_page) != head);

	if (fully_mapped)
		SetPageMappedToDisk(page);

	if (!nr) {
		/*
		 * All buffers are uptodate - we can set the page uptodate
		 * as well. But not if get_block() returned an error.
		 */
		if (!PageError(page))
			SetPageUptodate(page);
		unlock_page(page);
		return 0;
	}

	/* Stage two: lock the buffers */
	for (i = 0; i < nr; i++) {
		bh = arr[i];
		lock_buffer(bh);
		mark_buffer_async_read(bh);
	}

	/*
	 * Stage 3: start the IO.  Check for uptodateness
	 * inside the buffer lock in case another process reading
	 * the underlying blockdev brought it uptodate (the sct fix).
	 */
	for (i = 0; i < nr; i++) {
		bh = arr[i];
		if (buffer_uptodate(bh))
			end_buffer_async_read(bh, 1);
		else
			submit_bh(REQ_OP_READ, 0, bh);
	}
	return 0;
}
#+END_SRC
***** 処理の流れ
      1.buffer_head構造体の初期化（データの読み出し）
      2.初期化のエラーチェック
      3.バッファをロックし、同期を行う
      4.既にバッファが最新状態なら、そのバッファのREAD I/Oが終了したことをカーネルに通知し、
        そうでなければ、submit_bh関数を使って、カーネルに1ブロック分のデータを要求します。
	このとき、buffer_head構造体にブロックの論理番号などの情報が入っているので、
	submit_bhには読み込みを要求するREQ_OP_READとオプション（0）、bhだけを渡しています。
** bfs_writepage関数
*** 概要
    引数で渡されるpage構造体が指すページに対応するキャッシュを記憶装置と矛盾が無いように書き込む要請
    をカーネルに行います。これをBFSに対応した形で定義を行います。
*** 引数
**** 第一引数
     struct page *page
     Dirtyな状態のページキャッシュを指すpage構造体へのポインタ。
**** 第二引数
     struct writeback_control *wbc
     WriteBack処理を管理するためのwriteback_control構造体へのポインタ。
     WriteBack処理等を自前で実装するときに必要になるため、カーネルから渡される。
*** 返り値
*** 1行目
    block_write_full_page関数を呼び出しています。その結果を返し、終了です。block_read_full_pageと似ています。
    この関数に渡している引数は、ページキャッシュを指すpage構造体へのポインタと、
    BFSのブロックを読み込むための関数であるbfs_get_blockの関数ポインタを渡しています。
**** block_write_full_page関数
     block_read_full_page関数と同様で、WriteBack処理を行うための関数です。この関数が主に扱う処理は、
     WriteBack処理の書き込み操作の部分です。渡したDirtyなページの情報の同期をカーネルに要請します。
